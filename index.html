<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tipos de datos, marcas gráficas y canales de codificación visual</title>
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css" />
    <!-- <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css" />
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css" /> -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>

    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="container">
      <div class="columns">
        <div class="column col-12">
          <br />
          <p class="label">VISUALIZACIÓN DE DATOS | LTD - LED - UTDT</p>

          <h2>Tipos de datos, marcas y canales de codificación visual</h2>

          <p>
            Una visualización representa datos mediante una colección de marcas gráficas, como
            barras, líneas y símbolos de puntos. Los atributos de una marca, como su posición,
            forma, tamaño o color, sirven como canales en los que podemos codificar valores de datos
            subyacentes.
          </p>
          <img src="imgs/canvas.png" alt="" />
          <p>
            Con un marco básico de tipos de datos, marcas y canales de codificación, podemos crear
            de manera concisa una amplia variedad de visualizaciones. En este cuaderno, exploramos
            cada uno de estos elementos y mostramos cómo usarlos para crear gráficos estadísticos
            personalizados.
          </p>

          <h4>Datos de desarrollo mundial</h4>
          <p>
            Visualizaremos datos globales de salud y población para países del mundo, registradas
            durante los años 1955 a 2005. Los datos fueron recopilados por la Fundación Gapminder y
            compartidos en la popular charla TED de Hans Rosling. (Si no has visto la charla, ¡te
            animamos a que la veas!)
            <br /><br />
            Primero, carguemos el conjunto de datos
            <a href="./data/data.csv">data.csv</a> con d3. El método <code>d3.csv</code> de d3 lo
            transformará en una lista de objetos. El segundo parámetro (la función
            <code>d3.autoType</code>) convertirá automáticamente los valores del conjunto de datos
            al tipo correcto.
          </p>
          <pre><code class="language-js">
  d3.csv("ruta_al_archivo/data.csv", d3.autoType).then((data) => {
    console.table(data);
  });
          </code></pre>
          <p>
            El tamaño de los datos es de 693 filas por 6 columnas. Veamos el contenido de las
            primeras 10 filas:
          </p>

          <table class="table">
            <thead>
              <tr>
                <th>year</th>
                <th>country</th>
                <th>cluster</th>
                <th>pop</th>
                <th>life_expect</th>
                <th>fertility</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>1955</td>
                <td>"Afghanistan"</td>
                <td>A</td>
                <td>8891209</td>
                <td>30.332</td>
                <td>7.7</td>
              </tr>
              <tr>
                <td>1960</td>
                <td>"Afghanistan"</td>
                <td>A</td>
                <td>9829450</td>
                <td>31.997</td>
                <td>7.7</td>
              </tr>
              <tr>
                <td>1965</td>
                <td>"Afghanistan"</td>
                <td>A</td>
                <td>10997885</td>
                <td>34.02</td>
                <td>7.7</td>
              </tr>
              <tr>
                <td>1970</td>
                <td>"Afghanistan"</td>
                <td>A</td>
                <td>12430623</td>
                <td>36.088</td>
                <td>7.7</td>
              </tr>
              <tr>
                <td>1975</td>
                <td>"Afghanistan"</td>
                <td>A</td>
                <td>14132019</td>
                <td>38.438</td>
                <td>7.7</td>
              </tr>
              <tr>
                <td>1980</td>
                <td>"Afghanistan"</td>
                <td>A</td>
                <td>15112149</td>
                <td>39.854</td>
                <td>7.8</td>
              </tr>
              <tr>
                <td>1985</td>
                <td>"Afghanistan"</td>
                <td>A</td>
                <td>13796928</td>
                <td>40.822</td>
                <td>7.9</td>
              </tr>
              <tr>
                <td>1990</td>
                <td>"Afghanistan"</td>
                <td>A</td>
                <td>14669339</td>
                <td>41.674</td>
                <td>8</td>
              </tr>
              <tr>
                <td>1995</td>
                <td>"Afghanistan"</td>
                <td>A</td>
                <td>20881480</td>
                <td>41.763</td>
                <td>8</td>
              </tr>
              <tr>
                <td>2000</td>
                <td>"Afghanistan"</td>
                <td>A</td>
                <td>23898198</td>
                <td>42.129</td>
                <td>7.4792</td>
              </tr>
            </tbody>
          </table>
          <br /><br />
          <p>
            Para cada país (<code>country</code>) y año (<code>year</code>) (en intervalos de 5)
            tenemos medidas de fertilidad en términos del número de hijos por mujer
            (<code>fertility</code>), esperanza de vida en años ( <code>life_expect</code> ) y
            población total (<code>pop</code>). <br /><br />
            También vemos un campo de <code>cluster</code> con un código entero. ¿Qué podría
            representar esto? ¡Intentaremos resolver este misterio mientras visualizamos los datos!
            <br /><br />
            También vamos a crear una matriz de datos más pequeña, filtrada a valores solo para el
            año 2000 <a href="./data/data2000.csv">data2000.csv</a>
          </p>
          <!-- Tabla 2000 -->
          <table class="table">
            <thead>
              <tr>
                <th>year</th>
                <th>country</th>
                <th>cluster</th>
                <th>pop</th>
                <th>life_expect</th>
                <th>fertility</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>2000</td>
                <td>"Afghanistan"</td>
                <td>A</td>
                <td>23898198</td>
                <td>42.129</td>
                <td>7.4792</td>
              </tr>
              <tr>
                <td>2000</td>
                <td>"Argentina"</td>
                <td>D</td>
                <td>37497728</td>
                <td>74.34</td>
                <td>2.35</td>
              </tr>
              <tr>
                <td>2000</td>
                <td>"Aruba"</td>
                <td>D</td>
                <td>69539</td>
                <td>73.451</td>
                <td>2.124</td>
              </tr>
              <tr>
                <td>2000</td>
                <td>"Australia"</td>
                <td>E</td>
                <td>19164620</td>
                <td>80.37</td>
                <td>1.756</td>
              </tr>
              <tr>
                <td>2000</td>
                <td>"Austria"</td>
                <td>B</td>
                <td>8113413</td>
                <td>78.98</td>
                <td>1.382</td>
              </tr>
              <tr>
                <td>2000</td>
                <td>"Bahamas"</td>
                <td>D</td>
                <td>290075</td>
                <td>71.068</td>
                <td>2.1111</td>
              </tr>
              <tr>
                <td>2000</td>
                <td>"Bangladesh"</td>
                <td>A</td>
                <td>130406594</td>
                <td>62.013</td>
                <td>3.224</td>
              </tr>
              <tr>
                <td>2000</td>
                <td>"Barbados"</td>
                <td>D</td>
                <td>273483</td>
                <td>75.97</td>
                <td>1.5</td>
              </tr>
              <tr>
                <td>2000</td>
                <td>"Belgium"</td>
                <td>B</td>
                <td>10263618</td>
                <td>78.32</td>
                <td>1.638</td>
              </tr>
              <tr>
                <td>2000</td>
                <td>"Bolivia"</td>
                <td>D</td>
                <td>8152620</td>
                <td>63.883</td>
                <td>3.9585</td>
              </tr>
            </tbody>
          </table>
          <br /><br />

          <!-- Data types -->
          <h3>Tipos de datos</h3>
          <p>
            En una visualización efectiva son fundamentales los datos de entrada. Los valores de los
            datos pueden representar diferentes formas de medición. ¿Qué tipo de comparaciones
            admiten esas medidas? ¿Y qué tipos de codificaciones visuales respaldan esas
            comparaciones?
            <br /><br />

            Plot.js, la librería que utilizaremos a lo largo de la materia, infiere los tipos de
            datos. Esto significa que es importante que los datos de entrada sean del tipo correcto.
            Ejemplo, si tenemos un campo cuantitativo el dato debe ser de tipo numérico y no de tipo
            string.
            <br /><br />

            Comenzaremos observando los tipos de datos básicos en visualizaciones. Estos tipos de
            datos determinan los tipos de comparaciones que podemos hacer y, por lo tanto, guían
            nuestras decisiones de diseño de visualización.
          </p>
          <h5>Categóricos</h5>
          <p>
            Los datos <span class="label">categóricos</span>, también llamados datos
            <span class="label">nominales</span>, consisten en nombres de categorías. Con datos
            categóricos podemos comparar la igualdad de valores: ¿el valor A es igual o diferente al
            valor B? (A == B), podemos declarar "A es igual a B" o "A no es igual a B". En los datos
            de ejemplo, el campo <code>country</code> es nominal. Al visualizar datos nominales,
            debemos percibir fácilmente si los valores son iguales o diferentes: la posición, el
            tono del color (azul, rojo, verde, etc.) y la elección de distintas formas geométricas
            son opciones posibles. Por el contrario, el uso del tamaño para codificar datos
            nominales podría inducirnos a error, sugiriendo diferencias de magnitud entre valores
            que no existen.
          </p>

          <h5>Ordinales</h5>
          <p>
            Los datos <span class="label">ordinales</span> consisten en valores que tienen un orden
            específico. En este tipo de datos podemos comparar el orden de los valores: ¿el valor A
            viene antes o después del valor B? (A < B), podemos preguntar si "A es menor que B" o "A
            es mayor que B". En los datos de ejemplo, podemos tratar el campo <code>year</code> como
            ordinal. Al visualizar datos ordinales, debemos percibir una sensación de orden. Son
            apropiados la posición, el tamaño o el valor de brillo del color, mientras que el tono
            del color (que no está ordenado perceptivamente) sería menos adecuado.
          </p>

          <h5>Cuantitativos</h5>
          <p>
            Con datos <span class="label">cuantitativos</span> podemos medir diferencias numéricas
            entre valores. Existen múltiples subtipos de datos cuantitativos: <br /><br />
            Para datos de <span class="label">intervalo</span> podemos medir la distancia
            (intervalo) entre puntos: ¿cuál es la distancia del valor A al valor B? (A - B), podemos
            enunciar "A está a 12 unidades de distancia de B". <br /><br />
            Para los datos de <span class="label">relación</span>, el punto cero es significativo,
            por lo que también podemos medir proporciones o factores de escala: ¿qué proporción hay
            entre el valor A y el valor B? (A / B), podemos decir "A es el 10% de B" o "B es 7 veces
            más grande que A". <br /><br />
            En el conjunto de datos de ejemplo, el campo <code>year</code> es un intervalo
            cuantitativo (el valor del año "cero" es subjetivo), mientras que
            <code>fertility</code> y <code>life_expect</code> son campos de relación cuantitativa
            (el cero es significativo para calcular proporciones). <br /><br />
            Los valores cuantitativos se pueden visualizar mediante posición, tamaño o color (brillo
            u opacidad), entre otros canales. Un eje con una línea de base cero es esencial para las
            comparaciones proporcionales de valores de relación, pero se puede omitir para las
            comparaciones de intervalos.
          </p>

          <h5>Temporales</h5>
          <p>
            Los valores <span class="label">temporales</span> indican puntos o intervalos de tiempo.
            Este tipo es un caso especial de valores cuantitativos (marcas de fecha y hora) con una
            rica historia de convenciones (<a
              href="https://es.wikipedia.org/wiki/Calendario_gregoriano"
              >el calendario gregoriano</a
            >). <br /><br />
            Los valores temporales pueden incluir textos como "2019-01-04" o "04 de enero de 2019",
            así como fechas y horas estandarizadas como el formato de fecha y hora ISO:
            "2019-01-04T17:50:35.643Z" . No hay valores temporales en nuestro conjunto de datos ya
            que el campo <code>year</code> está codificado como un número entero. <br /><br />
            El tipo temporal en Vega-Lite admite el razonamiento sobre unidades de tiempo (año, mes,
            día, hora, etc.) y proporciona métodos para solicitar intervalos de tiempo específicos.
            Para obtener más detalles sobre los datos temporales en Vega-Lite, consulte la
            documentación de TimeUnit.
          </p>

          <h5>Resumen</h5>
          <p>
            Estos tipos de datos no se excluyen mutuamente, sino que forman una jerarquía: los datos
            ordinales admiten comparaciones nominales (igualdad), mientras que los datos
            cuantitativos admiten comparaciones ordinales (orden de rango). Además, estos tipos de
            datos no proporcionan una categorización fija. Por ejemplo, el hecho de que un campo de
            datos se represente con un número no significa que debamos tratarlo como un tipo
            cuantitativo. Podríamos interpretar un conjunto de edades (10 años, 20 años, etc.) como
            nominales (menores o mayores), ordinales (agrupados por años) o cuantitativos (calcular
            la edad promedio). Ahora examinemos cómo visualizar estos tipos de datos usando canales
            de codificación visual.
          </p>
          <hr />
          <h3>Canales de codificación visual</h3>
          <p>
            Para visualizar datos utilizamos <span class="label">marcas</span>: formas geométricas
            tales como barras, puntos y líneas. En Plot, en el array <code>marks</code> definimos la
            marca a utlizar (podemos usar más de una). <br /><br />
            Luego de definir la marca, vinculamos columnas de datos a las propiedades visuales de
            las marcas (el tipo de marca determina que canales se pueden utilizar). Estas
            propiedades visuales codifican datos abstractos y las llamamos
            <span class="label">canales</span>. Por ejemplo, podemos codificar la columna de
            fertilidad (<code>fertility</code>) con la posición x de la marca punto (dot)). Los
            canales más frecuentes son:
          </p>

          <ul>
            <li><code>x</code>: Posición horizontal (eje x) de la marca.</li>
            <li><code>y</code>: Posición vertical (eje y) de la marca.</li>
            <li>
              <code>fill</code>: Se puede especificar como un canal para codificar datos abstractos
              como color (especialmente para datos categóricos).
            </li>
            <li>
              <code>fillOpacity</code>: La opacidad, que va de 0 (totalmente transparente) a 1
              (totalmente opaco) se vincula generalmente a datos cuantitativos.
            </li>
            <li><code>curve</code>: tipo de curva para marcas de línea.</li>
            <li>
              <code>textAnchor</code>, <code>fontFamily</code>, <code>fontSize</code>,
              <code>fontStyle</code>, <code>fontVariant</code>, <code>fontWeight</code>: son
              atributos SVG (canales) vinculados a la marca textual (<code>text</code>).
            </li>
          </ul>
          <!-- chart_01_x -->
          <h4>x</h4>
          <p>
            El canal de codificación <b class="label">x</b> establece la posición horizontal de una
            marca: en este caso la coordenada x de la marca punto (<code>dot</code>). Además, las
            opciones predeterminadas de la leyenda así como las del eje las realiza automáticamente
            Plot. En el gráfico a continuación, vinculamos la columna <code>fertility</code> (datos
            cuantitativos) que da como resultado una escala lineal continua en el eje x:
          </p>
          <iframe id="chart_01_x" src="chart_01_x/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_01_x */
  Plot.plot({
    marks: [
      Plot.dot(data, { x: "fertility" }),
    ],
  });
          </code></pre>

          <!-- chart_02_y -->
          <h4>y</h4>
          <p>
            El canal de codificación <b class="label">y</b> establece la posición vertical de una
            marca (coordenada y). Aquí hemos agregado el campo de tipo ordinal <code>cluster</code>.
            Implícitamente Plot lo interpreta como valores categóricos (ya que son strings). El
            resultado es un eje vertical con valores discretos discretos.
          </p>
          <iframe src="chart_02_y/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_02_y */
  Plot.plot({
    marks: [
      Plot.dot(data, { x: "fertility", y: "cluster" }),
    ]
  });       

</code></pre>

          <!-- chart_03_x_y -->
          <p>
            ¿Qué sucede con el gráfico si al eje vertical vinculamos un campo cuantitativo?
            <br /><br />
            Si en lugar de <code>cluster</code> añadimos el campo <code>life_expect</code>, el
            resultado es un diagrama de dispersión. Eliminamos <code>type: "point"</code> ya que el
            campo es numérico y Plot interpreta que es cuantitativo:
            <!-- con escalas lineales para ambos ejes: -->
          </p>
          <iframe src="chart_03_x_y/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_03_x_y */
  Plot.plot({
    marks: [
      Plot.dot(data, { x: "fertility", y: "life_expect" }),
    ],
  });       

</code></pre>
          <!-- chart_03_x_y -->
          <p>
            Si queremos que las escalas incluyan el cero una de las maneras es indicarlo en los ejes
            con
            <code>zero: true</code>. En muchas situaciones es útil la extensión de los valores de
            las escalas con líneas horizontales para el eje vertical y verticales para el eje
            horizontal, en Plot podemos declarar la propiedad <code>grid: true</code> y
            <code>line: true</code> para reforzar las líneas de origen del gráfico. En el caso que
            el dominio (tanto en x como en y) no termine en un número entero o más legible podemos
            extenderlo con <code>nice: true</code>.
          </p>

          <iframe src="chart_03_x_y_grid/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_03_x_y_grid */
  Plot.plot({
    marks: [Plot.dot(data, { x: "fertility", y: "life_expect" })],
    x: { grid: true, line: true, zero: true, nice: true, },
    y: { grid: true, line: true, zero: true, nice: true, }
  });       

</code></pre>

          <h3>Tamaño</h3>
          <p>
            Podemos establecer el tamaño de una marca como canal para codificar valores. El
            significado del canal puede variar según el tipo de marca. Para las marcas de puntos
            (<code>dot</code>), el canal radio <code>r</code> hace que el área de los puntos sea
            proporcional al valor cuantitativo asociado. Se puede ajustar el tamaño del punto según
            sea necesario especificando explícitamente un rango con un array. Ej:
            <code>range: [3,15]</code> <br /><br />
            Enriquecemos nuestro gráfico de dispersión codificando la población (<code>pop</code>)
            en el canal de radio.
          </p>

          <!-- chart_05_size_a -->
          <iframe src="chart_05_size_a/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_05_size_a */
  Plot.plot({
    marks: [Plot.dot(data, { x: "fertility", y: "life_expect", r: "pop" })],
    nice: true,
    line: true,
    grid: true,
    zero: true,
  })       
          </code></pre>

          <!-- chart_05_size_b -->
          <p>
            En algunos casos, es posible que no estemos satisfechos con el rango del tamaño
            predeterminado. Para proporcionar otro intervalo, hay que asignar un array a la
            propiedad <code>range</code> del atributo radio (<code>r</code>) indique el tamaño más
            pequeño y el más grande. Aquí actualizamos la codificación de tamaño para que varíe de 0
            píxeles (para valores cero) a 50 píxeles de radio (para el valor máximo en el dominio de
            la escala).
          </p>
          <iframe src="chart_05_size_b/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_05_size_b */
  Plot.plot({
    marks: [Plot.dot(data, { x: "fertility", y: "life_expect", r: "pop" })],
    r: { range: [0, 50] }
    grid: true,
    line: true,
    nice: true,
  })          
</code></pre>

          <h3>Color y opacidad</h3>
          <p>
            El color también puede ser usado como canal de codificación. El estilo de la
            codificación de colores depende en gran medida del tipo de dato: los datos categóricos
            tendrán por defecto un esquema de color cualitativo de varios tonos, mientras que los
            cuantitativos utilizarán gradientes de color ordenados perceptivamente. <br /><br />
            Aquí, codificamos el campo cluster con el color del borde del círculo
            <code>stroke: "cluster"</code> lo que da como resultado un tono distinto para cada valor
            (A, B, C,...). Además indicamos en <code>color</code> la generación de una leyenda que
            muestra la correspondencia del color y el dato categórico <code>legend: true</code>.
          </p>
          <!-- chart_06_color_a -->
          <iframe src="chart_06_color_a/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_06_color_a */
  Plot.plot({
    grid: true,
    line: true,
    nice: true,
    color: {
      legend: true,
    },
    marks: [
      Plot.dot(data, {
        x: "fertility",
        y: "life_expect",
        stroke: "cluster",
        r: "pop",
      }),
    ],
  });
  
</code></pre>

          <!-- chart_06_color_b -->
          <p>
            También podemos usar el color en la superficie del círculo:
            <code>fill: "cluster"</code> y bajamos la opacidad a un valor menor a 1 para que no
            queden ocultas las superposiciones.
          </p>
          <iframe src="chart_06_color_b/index.html"></iframe>

          <pre><code class="language-js">
  /* chart_06_color_b */
  Plot.plot({
    marks: [
      Plot.dot(data, {
        x: "fertility",
        y: "life_expect",
        r: "pop",
        fill: "cluster",
      }),
    ],
    grid: true,
    line: true,
    nice: true,
    color: {
      legend: true,
    },
  });
</code></pre>

          <!-- chart_06_color_c -->
          <p>
            De forma predeterminada, Plot aplica los colores sin transparencia (opacidad = 1). Si le
            aplicamos a la opacidad un valor constante menor a 1 haremos visibles los círculos que
            están superpuestos.
          </p>
          <iframe src="chart_06_color_c/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_06_color_c */
  Plot.plot({
    marks: [
      Plot.dot(data, {
        x: "fertility",
        y: "life_expect",
        r: "pop",
        fill: "cluster",
        opacity: 0.5
      }),
    ],
    grid: true,
    line: true,
    nice: true,
    color: {
      legend: true,
    },
  });

</code></pre>

          <!-- chart_06_symbol -->
          <h3>Forma</h3>
          <p>
            El canal de codificación de formas (<code>symbol</code>) establece una forma geométrica
            distinta para cada dato categórico, en este caso lo usamos para codificar los clusters:
            <code>symbol: "cluster"</code>
            marcas de puntos. A diferencia de los otros canales que hemos visto hasta ahora, el
            canal de forma solo puede ser utilizado con la marca dot. El canal de codificación de
            forma solo debe usarse con datos categóricos, ya que no se admiten las comparaciones de
            magnitud y orden de rango perceptivo.
            <br /><br />
            Codificamos el campo de cluster usando tanto la forma como el color. El uso de múltiples
            canales para el mismo campo de datos subyacente se conoce como codificación redundante.
            El gráfico resultante combina información de color y forma en una sola leyenda de
            símbolo:
          </p>
          <iframe src="chart_06_symbol/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_06_symbol */
  Plot.plot({
    marks: [
      Plot.dot(data, {
        x: "fertility",
        y: "life_expect",
        r: "pop",
        fill: "cluster",
        symbol: "cluster",
      }),
    ],
    grid: true,
    line: true,
    nice: true,
    symbol: {
      legend: "true",
    },
  });

</code></pre>

          <h3><em>Tooltips</em></h3>
          <p>
            Llegados a este punto hemos creado un gráfico, ¡pero todavía no sabemos a qué países
            corresponden los puntos visualizados! Una opción es usar el canal
            <code>title</code> para visualizar el nombre del país. Con <code>title</code> Plot
            genera un <em>tooltip</em>, un rectángulo que crea el navegador cuando se produce un
            <em>hover</em> del mouse sobre la marca (el círculo). <br /><br />
            Al igual que los otros canales vinculamos el canal con el campo:
            <code>title: "country"</code>
          </p>
          <!-- chart_06_color_tooltip_a -->
          <iframe src="chart_06_tooltip_a/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_06_tooltip_a */
  Plot.plot({
    marks: [
      Plot.dot(data, {
        x: "fertility",
        y: "life_expect",
        r: "pop",
        fill: "cluster",
        opacity: 0.5,
        title: "country"
      }),
    ],
    grid: true,
    line: true,
    nice: true,
    color: {
      legend: true,
    },
  });

</code></pre>

          <!-- chart_06_color_tooltip_b -->
          <p>
            Mediante una función anónima de javascript podemos acceder a los distintos campos y
            concatenarlos para el <em>tooltip</em>. Por ejemplo, el nombre del país con la
            expectativa de vida y la fertilidad:
            <code
              >title: (d) => `${d.country}\nExpectativa: ${d.life_expect} años\nFertilidad:
              ${d.fertility}`</code
            >
          </p>
          <iframe src="chart_06_tooltip_b/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_06_tooltip_b */
  Plot.plot({
    marks: [
      Plot.dot(data, {
        x: "fertility",
        y: "life_expect",
        r: "pop",
        fill: "cluster",
        opacity: 0.5,
        title: (d) =>
          `${d.country}
          Expectativa: ${d.life_expect} años
          Fertilidad: ${d.fertility}`,
      }),
    ],
    grid: true,
    line: true,
    nice: true,
    color: {
      legend: true,
    },
  });

</code></pre>

          <!-- chart_06_text_b -->
          <p>
            Otra opción es agregar una marca de texto con el nombre del país. En Plot debemos sumar
            una marca <code>text</code> en el array <code>marks</code>:
          </p>
          <iframe src="chart_06_text_a/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_06_text_a */
  Plot.plot({
    marks: [
      Plot.dot(data, {
        x: "fertility",
        y: "life_expect",
        r: "pop",
        fill: "cluster",
        opacity: 0.4,
      Plot.text(data, {
        x: "fertility",
        y: "life_expect",
        text: "country",
      }),
    ],
    grid: true,
    line: true,
    nice: true,
    color: {
      legend: true,
    },
  });

</code></pre>
          <!-- chart_06_text_b -->
          <p>
            Para evitar la superposición de los nombres podemos imprimir los países de mayor
            población pasando una función anónima filtrando aquellos países con población mayor a
            100 millones de habitantes:
            <code>text: (d) => (d.pop > 100000000 ? d.country : "")</code>
          </p>
          <iframe src="chart_06_text_b/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_06_text_b */
  Plot.plot({
    marks: [
      Plot.dot(data, {
        x: "fertility",
        y: "life_expect",
        r: "pop",
        fill: "cluster",
        opacity: 0.4,
      Plot.text(data, {
        x: "fertility",
        y: "life_expect",
        text: (d) => (d.pop > 100000000 ? d.country : ""),
      }),
    ],
    grid: true,
    line: true,
    nice: true,
    color: {
      legend: true,
    },
  });

</code></pre>
          <h3 id="faces">Faces</h3>
          <p>
            La posición espacial es uno de los canales más poderosos y flexibles para la
            codificación visual, pero ¿qué podemos hacer si ya tenemos campos asignados a los
            canales x e y? Una técnica valiosa es crear una grilla de gráficos, que conste de
            subgráficos que muestran un subconjunto de los datos. Es técnica más general para
            presentar datos utilizando pequeños múltiplos de vistas (<em
              ><a href="https://en.wikipedia.org/wiki/Small_multiple" target="_blank"
                >small multiples</a
              ></em
            >, Tufte). <br /><br />
            En Plot se lo denomina <code>facet</code>. Debemos indicar el conjunto de datos
            (<code>data</code>), el campo categórico que definirá los subgráficos y se aplicará la
            grilla y el eje (x o y). En este ejemplo mapeamos <code>cluster</code> sobre el eje x
            generando una fila horizontal de gráficos:
          </p>

          <!-- chart_07_facets_a -->
          <iframe src="chart_07_facets_a/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_07_facets_a */
  Plot.plot({
    grid: true,
    nice: true,
    zero: true,
    color: {
      legend: true,
    },
    facet: {
      data: data,
      x: "cluster",
    },
    marks: [
      Plot.dot(data, {
        x: "fertility",
        y: "life_expect",
        fill: "cluster",
        fillOpacity: 0.6,
        r: "pop",
        title: "country",
      }),
    ],
  });

</code></pre>

          <!-- chart_07_facets_b -->
          <p>
            El gráfico anterior queda desproporcionado con las medidas predeterminadas, lo que
            dificulta la comparación de las subgráficos entre sí. Podemos asignar nuevos valores a
            las propiedades de ancho y alto para crear un conjunto más pequeño de múltiplos. Y
            ajustar el rango del radio del círculo. Además, dado que los encabezados de los
            subgráficos etiquetan los valores de cluster, podemos eliminar la leyenda de color.
          </p>
          <iframe src="chart_07_facets_b/index.html"></iframe>
          <pre><code class="language-js">
/* chart_07_facets_b */
Plot.plot({
  grid: true,
  nice: true,
  zero: true,
  width: 800,
  height: 200,
  r: { range: [0, 18] },
  facet: {
    data: data,
    x: "cluster",
  },
  marks: [
    Plot.dot(data, {
      x: "fertility",
      y: "life_expect",
      fill: "cluster",
      fillOpacity: 0.6,
      r: "pop",
      title: "country",
    }),
  ],
});

</code></pre>
          <h4>Filtrado interactivo</h4>
          <p>
            En módulos posteriores, estudiaremos técnicas de interacción para la exploración de
            datos. Acá hay un adelanto: vinculamos un <em>slider</em> al campo
            <code>year</code> para permitirle al usuario filtrar los datos por año. No se preocupe
            si el código del proyecto <code>chart_08_slider</code> es un poco confuso en este punto,
            ya que más adelante cubriremos la interacción en detalle. Arrastre el slider hacia
            adelante y hacia atrás para ver cómo cambian los valores de los datos en el tiempo.
          </p>
          <!-- chart_08_slider -->
          <iframe src="chart_08_slider/index.html"></iframe>
          <hr />
          <h2 id="marcas">Marcas gráficas</h2>
          <p>
            En la exploración de canales de codificación utilizamos (casi) exclusivamente marcas de
            puntos (<code>Plot.dot()</code>) para visualizar datos. Sin embargo, el tipo de marca de
            punto es solo una de las muchas formas geométricas que se pueden usar para representar
            datos visualmente. Plot.js incluye varios tipos de marcas. Algunas de ellas son:
          </p>
          <ul>
            <li><code>dot()</code>: Círculos u otras formas geométricas.</li>
            <li>
              <code>areaX()</code>
              /
              <code>areaY</code>: Áreas rellenas definidas por una línea superior y una línea base.
            </li>

            <li><code>barX()</code> / <code>barY</code>: Barras rectangulares.</li>
            <li><code>line()</code> Segmentos de línea conectados.</li>
            <li><code>cell()</code> Celdas: rectángulos rellenos, útiles para mapas de calor.</li>
            <li><code>text()</code> Puntos (coordenadas x, y) representados por texto.</li>
            <li>
              <code>tick()</code> Líneas horizontales o verticales en donde el eje de la posición es
              cuantitativo y el otro eje es categórico.
            </li>

            <li>
              Para la lista completa de marcas consultar la documentación de Plot.js
              <a href="https://observablehq.com/@observablehq/plot#marks"
                >Todas las marcas de Plot.js</a
              >. A continuación, veremos paso a paso algunos de los tipos de marcas más utilizados
              para gráficos estadísticos.
            </li>
          </ul>

          <!-- chart_09_dot_mark_symbol-->
          <!-- <iframe src="chart_09_dot_mark_symbol/index.html"></iframe> -->

          <!-- chart_10_dot_mark -->
          <h4>Marcas de punto</h4>
          <p>
            Además de codificar canales, podemos elegir distintos tipos de marcas gráficas de
            acuardo a lo querramos comunicar con los datos con
            <code>Plot.nombre_de_la_marca()</code>. <br /><br />
            La marca de punto <code>dot()</code>
            representa los datos como círculos, frecuentemente colocados en dimensiones
            cuantitativas x e y, como en un gráfico de dispersión. Por ejemplo, el siguiente
            diagrama de dispersión muestra la relación aproximadamente inversa entre la expectativa
            de vida en y↑ y la fertilidad en x→
          </p>
          <iframe src="chart_10_dot_mark/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_10_dot_mark */
  Plot.plot({
    height: 200,
    width: 500,
    line: true,
    nice: true,
    zero: true,
    grid: true,
    marks: [
      Plot.dot(data, {
        x: 'fertility',
        y: 'life_expect',
      }),
    ],
  })
            
            </code></pre>
          <!-- chart_10_dot_mark_square -->
          <p>
            Con la marca punto se pueden elegir, además del círculo, otras formas geométricas
            utilizando la propiedad
            <code>symbol</code>. Disponibles: cruz <code>cross</code>, rombo <code>diamond</code>,
            cuadrado <code>square</code>, estrella <code>star</code>, triangle
            <code>triangle</code>, "Y" <code>wye</code>
          </p>
          <iframe src="chart_10_dot_mark_square/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_10_dot_mark_square */
  Plot.plot({
    width: 600,
    height: 200,
    line: true,
    nice: true,
    zero: true,
    grid: true,
    marks: [
      Plot.dot(data, {
        x: 'fertility',
        y: 'cluster',
        fillOpacity: 0.6,
        symbol: 'square',
      }),
    ],
  })
            
            </code></pre>

          <!-- chart_11_tick_mark -->
          <h4>Marcas de tilde (<i>tick</i>)</h4>
          <p>
            Los <i>ticks</i> son líneas horizontales o verticales. Un tickY↔︎ tiene un valor y,
            mientras que un tickX↕︎ tiene un valor x. Los ticks se usan habitualmente para mostrar
            distribuciones unidimensionales, como en el gráfico de "código de barras" a continuación
            que muestra la densidad de fertilidad en cada cluster de países.
          </p>
          <iframe src="chart_11_tick_mark/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_11_tick_mark */
  Plot.plot({
    marks: [
      Plot.tickX(data, {
        x: 'fertility',
        y: 'cluster',
      }),
    ],
    width: 600,
    height: 200,
    line: true,
    nice: true,
    grid: true,
  })
            
            </code></pre>

          <h4>Marca de barras</h4>
          <!-- chart_12_bar_mark_a -->
          <p>
            El tipo de marca de barras dibuja un rectángulo con una posición, un ancho y un alto.
            <br /><br />
            El siguiente gráfico es un gráfico de barras verticales <code>barY()</code> simple de la
            población (<code>pop</code>) de cada país. Con la función <code>sort()</code> de d3
            ordenamos el dominio de <b>x</b> de manera descendente según la población.
          </p>
          <iframe src="chart_12_bar_mark_a/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_12_bar_mark_a */
  Plot.plot({
    marks: [
      Plot.barY(data, {
        x: 'country',
        y: 'pop',
      }),
    ],
    x: {
      domain: d3.sort(data, (a, b) => d3.descending(a.pop, b.pop)).map(d => d.country),
      tickRotate: -45,
    },
    y: {
      grid: true,
    },
    height: 400,
    width: 1000,
    marginLeft: 100,
    marginBottom: 100,
  })
            
            </code></pre>
          <!-- chart_12_bar_mark_group -->
          <p>
            El ejemplo anterior crea un gráfico de barras a partir de una línea de base cero, y el
            canal <strong>y</strong> solo codifica el valor distinto de cero con la longitud de la
            barra. Sin embargo, la marca de barra también permite especificar puntos de inicio y
            final para visualizar rangos. <br /><br />
            El siguiente gráfico utiliza los canales <b>x1</b> (punto de partida) y <b>x2</b> (punto
            final) para mostrar el rango de fertilidad dentro de cada grupo regional (cluster).
            Utilizamos las funciones de agregación mínimo y máximo para determinar los extremos del
            rango. Previamente agrupamos por cluster con la función de transformación
            <code>groupY</code>.
          </p>
          <iframe src="chart_12_bar_mark_group/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_12_bar_mark_group */
  Plot.plot({
    marks: [
      Plot.barX(
        data,
        Plot.groupY(
          {
            x1: 'min',
            x2: 'max',
          },
          { x: 'fertility', y: 'cluster' },
        ),
      ),
    ],
    x: {
      label: 'Min of life_expect, Max of life_expect',
    },
    height: 200,
    width: 600,
    grid: true,
    nice: true,
    line: true,
            </code></pre>
          <p>
            Las barras también se pueden apilar cuando queremos mostrar una suma representada por
            casos individuales. En este caso, mostramos la suma de la población por grupo de países.
            Para esto cambiemos la codificación <b>x</b> por <b>cluster</b> y codificamos al país
            usando el canal de color. También desactivamos la leyenda (que sería muy larga con
            colores para todos los países). En su lugar usamos a la propiedad
            <code>title</code> para generar <em>tooltips</em>, por hover del usuario, con el nombre
            del país y la población.
          </p>

          <!-- chart_12_bar_mark_stacked -->
          <iframe src="chart_12_bar_mark_stacked/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_12_bar_mark_stacked */
  Plot.plot({
    marks: [
      Plot.barY(data, {
        x: 'cluster',
        y: 'pop',
        fill: 'country',
        sort: 'pop',
        title: d => d.country + '\n' + d.pop,
      }),
    ],
    marginLeft: 70,
    width: 300,
  })
            </code></pre>

          <h4>Marca de línea</h4>
          <p>
            La marca de línea (<code>line()</code>) conecta puntos con una línea. A través de la
            pendiente de una línea se puede comunicar, por ejemplo, la tasa de cambio de una
            variable.
            <br /><br />
            Hagamos un gráfico de líneas múltiples de la fertilidad por país a lo largo de los años
            utilizando los datos de desarrollo mundial sin filtrar. Podemos ver variaciones en cada
            país y tendencias generales de menor número de hijos por familia a lo largo del tiempo.
          </p>

          <!-- chart_13_line_mark_a -->
          <iframe src="chart_13_line_mark_a/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_13_line_mark_a */
  Plot.plot({
    marks: [
      Plot.line(data, {
        x: 'year',
        y: 'fertility',
        z: 'country',
        stroke: 'country',
      }),
    ],
    x: {
      tickFormat: 'd',
    },
  })
            </code></pre>
          <p>
            Cambiemos algunos de los parámetros de marca predeterminados para personalizar el
            gráfico. Podemos configurar el ancho del trazo para determinar el grosor de las líneas y
            la opacidad para agregar algo de transparencia. De forma predeterminada, la marca de
            línea utiliza segmentos de línea recta para conectar puntos de datos.
            <br /><br />
            En algunos casos, es posible que queramos suavizar las líneas. Podemos ajustar la
            interpolación utilizada para conectar puntos de datos configurando el parámetro de marca
            de interpolación. Usemos la interpolación 'monótona' para proporcionar líneas suaves que
            también garanticen que no generarán inadvertidamente valores mínimos o máximos "falsos"
            como resultado de la interpolación.
          </p>
          <!-- chart_13_line_mark_b -->
          <iframe src="chart_13_line_mark_b/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_13_line_mark_b */
  Plot.plot({
    marks: [
      Plot.line(data, {
        x: 'year',
        y: 'fertility',
        z: 'country',
        stroke: 'country',
        strokeWidth: 3,
        opacity: 0.5,
        curve: 'natural',
      }),
    ],
  })
            </code></pre>

          <p>
            Al graficar muchas líneas, es necesario usar el canal <b>z</b> para agrupar datos
            ordenados en series. Por ejemplo, los gráficos muestran las tasas de fertilidad en donde
            cada línea es un país y debemos indicarlo en <b>z</b> (<code>z: country</code>).
            <br /><br />
            Una misma línea puede variar su color. Si el valor codificado en
            <code>stroke</code> varía dentro de la serie, la línea se segmentará por color. (El
            mismo comportamiento se aplica a otros canales, como <code>strokeWidth</code> y
            <code>title</code>). En este caso, las caídas de fertilidad se visualizan con el cambio
            de colores cálidos a fríos.
          </p>

          <!-- chart_13_line_mark_a_color -->
          <iframe src="chart_13_line_mark_highlight/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_13_line_mark_highlight */
  Plot.plot({
    marks: [
      Plot.line(data, {
        x: 'year',
        y: 'fertility',
        z: 'country',
        stroke: 'fertility',
      }),
    ],
    x: {
      tickFormat: 'd',
    },
  })
                  </code></pre>
          <p>
            La marca <code>line</code> también se puede utilizar para crear gráficos de pendientes
            (también llamados de coordenadas paralelas), gráficos que resaltan el cambio de valor
            entre dos puntos utilizando las pendientes. <br /><br />
            A continuación, creamos un gráfico de pendiente que compara las poblaciones de cada país
            en los años mínimo y máximo en nuestro conjunto de datos: 1955 y 2005. Para esto
            filtramos los datos de esos años:
            <code>data.filter(d => d.year == 1955 || d.year == 2005)</code>
            <br /><br />
          </p>
          <!-- chart_13_line_mark_c -->
          <iframe src="chart_13_line_mark_c/index.html"></iframe>
          <pre><code class="language-js">
  /* chart_13_line_mark_c */
  Plot.plot({
    marks: [
      Plot.line(
        data.filter(d => d.year == 1955 || d.year == 2005),
        {
          x: 'year',
          y: 'pop',
          stroke: 'country',
          opacity: 0.7,
        },
      ),
    ],
    x: {
      tickFormat: 'd',
      type: 'ordinal',
    },
    y: {
      tickFormat: d3.format(',.0f'),
      ticks: 6,
      zero: true,
    },
    width: 300,
    marginLeft: 70,
    line: true,
  })
                  </code></pre>
          <p>
            Para este tipo de gráficos en Plot se puede utilizar la marca <code>link</code> donde
            hay que transformar un poco los datos para que se adapte mejor al tipo de marca.
            <a href="./chart_13_link_mark/script.js"
              >Ver código del mismo ejemplo utilizando la marca <code>link</code></a
            >
          </p>

          <!-- chart_14_area_mark_a -->
          <iframe src="chart_14_area_mark_a/index.html"></iframe>
          <!-- chart_14_area_mark_b -->
          <iframe src="chart_14_area_mark_b/index.html"></iframe>
          <!-- chart_14_area_mark_c -->
          <iframe src="chart_14_area_mark_c/index.html"></iframe>
          <!-- chart_14_area_mark_d -->
          <iframe src="chart_14_area_mark_d/index.html"></iframe>
          <!-- chart_14_area_mark_e -->
          <iframe src="chart_14_area_mark_e/index.html"></iframe>
          <!-- chart_14_area_mark_f -->
          <iframe src="chart_14_area_mark_f/index.html"></iframe>
          <!-- chart_15_two_marks_a -->
          <iframe src="chart_15_marks_a/index.html"></iframe>
          <!-- chart_15_two_marks_b -->
          <iframe src="chart_15_marks_b/index.html"></iframe>
          <a
            href="https://observablehq.com/@uwdata/data-types-graphical-marks-and-visual-encoding-channels?collection=@uwdata/visualization-curriculum"
            >UW Interactive Data Lab. Data Types, Graphical Marks, and Visual Encoding Channels
          </a>
        </div>
      </div>
    </div>
    <!-- <script type="text/javascript" src="https://pym.nprapps.org/pym.v1.min.js"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/iframe-resizer/4.3.2/iframeResizer.min.js"></script>
    <script>
      hljs.highlightAll()
      iFrameResize({})
      // iFrameResize();
      // var pymParent = new pym.Parent("chart_01_x", "./chart_01_x/index.html", {});
    </script>
  </body>
</html>
